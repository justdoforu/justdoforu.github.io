import{_ as p}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as t,o as e,c as o,b as n,d as c,e as i,a as s}from"./app-cbOojWoE.js";const l={},u=s('<h1 id="函数式编程" tabindex="-1"><a class="header-anchor" href="#函数式编程" aria-hidden="true">#</a> 函数式编程</h1><h2 id="函数式编程思维" tabindex="-1"><a class="header-anchor" href="#函数式编程思维" aria-hidden="true">#</a> 函数式编程思维</h2><p>函数式编程（Functional Programming，简称FP）是一种编程范式，它将计算视为数学函数的计算，避免使用可变状态和可变数据。函数式编程强调使用纯函数（Pure Functions）和不可变数据（Immutable Data），并且避免副作用（Side Effects）。</p><p>以下是函数式编程的一些主要概念和特点：</p><ol><li><p><strong>纯函数（Pure Functions）：</strong> 纯函数是没有副作用的函数，其输出仅由输入决定，不依赖于系统状态或外部变量。相同的输入始终产生相同的输出，这使得纯函数更容易理解、测试和并发执行。</p></li><li><p><strong>不可变数据（Immutable Data）：</strong> 函数式编程强调数据的不可变性，即一旦数据被创建，就不能被修改。这可以通过创建新的数据副本而不是直接修改现有数据来实现。不可变性有助于避免副作用，并简化代码的推理和理解。</p></li><li><p><strong>高阶函数（Higher-Order Functions）：</strong> 函数可以作为参数传递给其他函数，也可以作为返回值。这种能力使得函数可以更灵活地组合和复用。</p></li><li><p><strong>递归（Recursion）：</strong> 函数式编程鼓励使用递归而不是循环。递归是一种自身调用的技术，用于解决问题并遍历数据结构。</p></li><li><p><strong>不可变性集合（Immutable Collections）：</strong> 函数式编程语言通常提供一些不可变的数据结构，如不可变列表、不可变集合等，以支持函数式编程的理念。</p></li><li><p><strong>Lambda 表达式（Lambda Expressions）：</strong> Lambda 表达式是一种匿名函数，可以在需要函数的地方定义和使用它，而不必显式地声明一个命名函数。</p></li><li><p><strong>惰性求值（Lazy Evaluation）：</strong> 函数式编程语言通常支持惰性求值，即只在需要时才计算表达式的值。这有助于提高性能和避免不必要的计算。</p></li><li><p><strong>模式匹配（Pattern Matching）：</strong> 模式匹配是一种在数据结构中查找模式并执行相应操作的技术。它在函数式编程中被广泛使用。</p></li></ol><p>函数式编程的一个优点是它有助于编写清晰、简洁和可维护的代码。它也能更容易地进行并行化和异步编程，因为纯函数没有共享的状态。一些函数式编程语言包括Haskell、Scala、Clojure和部分支持的编程语言，如JavaScript和Python。</p>',6),r={href:"https://prepack.io/",target:"_blank",rel:"noopener noreferrer"},d=s(`<h2 id="函数柯里化" tabindex="-1"><a class="header-anchor" href="#函数柯里化" aria-hidden="true">#</a> 函数柯里化</h2><p>柯里化（Currying）是函数式编程中的一种技术，它是将一个多参数的函数转换为一系列单参数函数的过程。这些单参数函数返回新的函数，每个新函数接受下一个参数，直到所有参数都被收集完毕，最后返回最终的结果。柯里化的名字来源于数学家 Haskell Curry。</p><p>考虑一个普通的二元函数：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 5</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过柯里化，我们可以将这个函数转换为一系列单参数函数：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">curryAdd</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 使用柯里化后的函数</span>
<span class="token keyword">const</span> add2 <span class="token operator">=</span> <span class="token function">curryAdd</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">add2</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 5</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的例子中，<code>curryAdd</code> 是一个柯里化函数，它接受一个参数 <code>x</code>，返回一个函数，这个返回的函数接受参数 <code>y</code>，并返回 <code>x + y</code> 的结果。通过这种方式，我们可以逐步传递参数，形成一个链式调用的过程。</p><p>柯里化的优势包括：</p><ol><li><p><strong>参数复用：</strong> 可以通过部分应用（Partial Application）固定一部分参数，从而创建新的函数。在上面的例子中，<code>add2</code> 就是通过柯里化的方式部分应用了 <code>add</code> 函数。</p></li><li><p><strong>提高函数灵活性：</strong> 柯里化使得函数更加灵活，可以更容易地适应不同的调用方式和场景。</p></li><li><p><strong>函数组合：</strong> 柯里化是实现函数组合的一种方式，可以将多个函数组合在一起，形成新的函数。</p></li></ol><p>在一些函数式编程语言中，柯里化是一种自然而然的编程风格，并且一些库和框架提供了方便的柯里化函数。在 JavaScript 中，由于它是一门多范式的语言，你可以手动实现柯里化，也可以使用一些库来简化这个过程。例如，在 Lodash 中，有一个 <code>curry</code> 函数可以用于柯里化。</p><h2 id="函数的反柯里化" tabindex="-1"><a class="header-anchor" href="#函数的反柯里化" aria-hidden="true">#</a> 函数的反柯里化</h2><p>反柯里化（Uncurrying）是柯里化的逆操作。在柯里化中，一个多参数的函数被转化为一系列单参数的函数，而反柯里化则是将一系列单参数的函数转化为一个多参数的函数。</p><p>下面是一个简单的 JavaScript 示例来说明反柯里化：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 柯里化的例子</span>
<span class="token keyword">function</span> <span class="token function">curryAdd</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 反柯里化的实现</span>
<span class="token keyword">function</span> <span class="token function">uncurryAdd</span><span class="token punctuation">(</span><span class="token parameter">curriedAdd</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">curriedAdd</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 使用反柯里化后的函数</span>
<span class="token keyword">const</span> uncurriedAdd <span class="token operator">=</span> <span class="token function">uncurryAdd</span><span class="token punctuation">(</span>curryAdd<span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">uncurriedAdd</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 5</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，<code>curryAdd</code> 是一个柯里化的函数，而 <code>uncurryAdd</code> 是一个用于反柯里化的函数。<code>uncurriedAdd</code> 接受两个参数，然后通过调用 <code>curriedAdd</code> 的方式返回结果。</p><p>反柯里化的目的通常是为了在函数式编程中更方便地使用那些本来是多参数的函数，尤其是在与某些 API 或库进行交互时。某些情况下，反柯里化也能够提高代码的可读性和易用性。</p><p>需要注意的是，并非所有函数都能被良好地反柯里化。有时候，函数的参数和返回值的结构可能不够一致，这就会导致反柯里化不够直观或者不可行。</p><h2 id="高阶函数" tabindex="-1"><a class="header-anchor" href="#高阶函数" aria-hidden="true">#</a> 高阶函数</h2><p>高阶函数是指接受一个或多个函数作为参数，并/或者返回一个新函数的函数。在函数式编程中，高阶函数是一种强大的抽象工具，它们能够接受其他函数作为参数，使得代码更加灵活、模块化和可复用。</p><p>以下是一些常见的高阶函数的例子：</p><ol><li><p><strong>map：</strong> 接受一个函数和一个列表，并对列表中的每个元素应用该函数，返回一个新的列表。例如，JavaScript 中的 <code>Array.map</code>。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> squaredNumbers <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">x</span> <span class="token operator">=&gt;</span> x <span class="token operator">*</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// squaredNumbers 现在是 [1, 4, 9, 16, 25]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>filter：</strong> 接受一个函数和一个列表，并返回一个新的列表，其中包含满足给定函数条件的元素。例如，JavaScript 中的 <code>Array.filter</code>。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> evenNumbers <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token parameter">x</span> <span class="token operator">=&gt;</span> x <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// evenNumbers 现在是 [2, 4]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>reduce：</strong> 接受一个函数、一个初始值和一个列表，将列表中的元素逐个应用到函数上，累积结果。例如，JavaScript 中的 <code>Array.reduce</code>。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> sum <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">acc<span class="token punctuation">,</span> x</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> acc <span class="token operator">+</span> x<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// sum 现在是 15</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>函数作为参数：</strong> 高阶函数可以接受其他函数作为参数，例如，JavaScript 中的 <code>setTimeout</code> 函数。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">delayedGreeting</span><span class="token punctuation">(</span><span class="token parameter">callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">callback</span><span class="token punctuation">(</span><span class="token string">&#39;Hello, World!&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">delayedGreeting</span><span class="token punctuation">(</span><span class="token parameter">message</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1秒后输出 &quot;Hello, World!&quot;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>函数作为返回值：</strong> 高阶函数也可以返回一个新的函数，例如，JavaScript 中的柯里化函数。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">multiplyBy</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> x <span class="token operator">*</span> y<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> double <span class="token operator">=</span> <span class="token function">multiplyBy</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">double</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 10</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><p>高阶函数的使用有助于提高代码的可读性、简洁性和复用性。它们是函数式编程风格的核心概念，也在许多编程语言中得到广泛应用。</p><h2 id="尾调用优化" tabindex="-1"><a class="header-anchor" href="#尾调用优化" aria-hidden="true">#</a> 尾调用优化</h2><p>尾调用优化（Tail Call Optimization，简称TCO）是一种编译器优化技术，它优化了函数的尾调用，以减少函数调用的栈空间占用。尾调用是指一个函数的最后一个操作是调用另一个函数。</p><p>在没有尾调用优化的情况下，每次函数调用都会在调用栈上创建一个新的帧（stack frame），这可能导致栈溢出，特别是对于递归调用层次很深的函数。尾调用优化通过复用当前函数的栈帧，而不是创建新的帧，从而减少了栈空间的使用。</p><p>一个满足尾调用优化条件的函数必须满足两个条件：</p><ol><li>函数的最后一个操作必须是对另一个函数的调用。</li><li>调用的结果必须直接返回，而不经过其他的操作。</li></ol><p>以下是一个满足尾调用优化条件的例子：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token parameter">n<span class="token punctuation">,</span> acc <span class="token operator">=</span> <span class="token number">1</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> acc<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 尾调用</span>
  <span class="token keyword">return</span> <span class="token function">factorial</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> n <span class="token operator">*</span> acc<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 尾调用优化后，不会产生栈溢出</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 120</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在一些支持尾调用优化的编程语言中，编译器可以检测到这种尾调用的情况，并进行优化。然而，并非所有的编程语言都支持尾调用优化，例如，JavaScript 的尾调用优化支持度较低。</p><p>在实际编程中，可以通过使用迭代而不是递归来避免栈溢出问题，因为迭代通常更容易被优化。一些函数式编程语言，如Scheme，通常对尾调用提供了更好的支持。</p><h2 id="尾递归" tabindex="-1"><a class="header-anchor" href="#尾递归" aria-hidden="true">#</a> 尾递归</h2><p>尾递归是指在递归函数中，递归调用是函数的最后一步操作。尾递归是一种特殊的递归形式，具有尾调用的特性，使得编译器或解释器可以对其进行优化，减少栈空间的使用，从而避免栈溢出。</p><p>以下是一个尾递归的例子，计算阶乘：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 尾递归的阶乘函数</span>
<span class="token keyword">function</span> <span class="token function">factorialTailRecursive</span><span class="token punctuation">(</span><span class="token parameter">n<span class="token punctuation">,</span> acc <span class="token operator">=</span> <span class="token number">1</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> acc<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 尾递归调用</span>
  <span class="token keyword">return</span> <span class="token function">factorialTailRecursive</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> n <span class="token operator">*</span> acc<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 使用尾递归计算阶乘，不会产生栈溢出</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">factorialTailRecursive</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 120</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的例子中，递归调用 <code>factorialTailRecursive</code> 是函数的最后一步，它满足尾递归的条件。这样的尾递归函数可以被一些编程语言的编译器或解释器进行尾调用优化，将其转化为迭代形式，避免了栈的不断增长。</p><p>需要注意的是，并非所有编程语言和所有情况都能够进行尾调用优化。在一些支持尾调用优化的语言中，如Scheme，尾递归是一种通常推荐的写法，而在一些不支持尾调用优化的语言中，可能需要使用迭代或其他方法来避免栈溢出问题。JavaScript 目前对尾调用的优化支持较低，不同的引擎和环境可能有不同的行为。</p><h2 id="闭包" tabindex="-1"><a class="header-anchor" href="#闭包" aria-hidden="true">#</a> 闭包</h2><p>闭包（Closure）是指在一个函数内部定义的函数，能够访问到其外部函数的变量，即使在外部函数执行结束后，内部函数仍然能够访问并保持对外部函数作用域的引用。闭包在很多编程语言中都是一种强大的概念，它使得函数成为一等公民，并提供了一种保存状态的机制。</p><p>在理解闭包之前，让我们先看一个简单的例子：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">outerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> outerVariable <span class="token operator">=</span> <span class="token string">&#39;I am from outer!&#39;</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">innerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>outerVariable<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> innerFunction<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> closureFunction <span class="token operator">=</span> <span class="token function">outerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">closureFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 &quot;I am from outer!&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，<code>innerFunction</code> 是一个闭包。当 <code>outerFunction</code> 被调用时，它创建了 <code>outerVariable</code> 变量，并定义了 <code>innerFunction</code>，然后将 <code>innerFunction</code> 返回。当我们调用 <code>outerFunction</code> 后，它返回的是 <code>innerFunction</code>，并且我们将其赋值给 <code>closureFunction</code>。最后，我们调用 <code>closureFunction</code>，它仍然能够访问和引用 <code>outerVariable</code>，即使 <code>outerFunction</code> 已经执行完毕。</p><p>闭包具有以下特点：</p><ol><li><p><strong>访问外部函数的变量：</strong> 内部函数可以访问外部函数的变量，即使外部函数已经执行完毕。</p></li><li><p><strong>保存状态：</strong> 由于闭包可以访问外部函数的变量，它可以保存这些变量的状态，使得这些变量的值得以保留。</p></li><li><p><strong>作为函数返回值：</strong> 通常，闭包被用作函数的返回值，以便在外部函数执行后仍然能够访问外部作用域中的变量。</p></li></ol><p>闭包在很多情况下都是非常有用的，例如，用于封装私有变量、实现柯里化、创建回调函数等。在 JavaScript 中，由于函数是一等公民，闭包是一种常见且强大的编程模式。</p><h2 id="实践网站" tabindex="-1"><a class="header-anchor" href="#实践网站" aria-hidden="true">#</a> 实践网站</h2><ul><li>https://lodash.com/</li><li>https://github.com/gcanti/fp-ts</li></ul>`,47);function k(v,m){const a=t("ExternalLinkIcon");return e(),o("div",null,[u,n("p",null,[n("a",r,[c("prepack"),i(a)])]),d])}const f=p(l,[["render",k],["__file","函数式编程.html.vue"]]);export{f as default};

import{_ as i}from"./plugin-vue_export-helper-x3n3nnut.js";import{o,c as l,a as e}from"./app-cbOojWoE.js";const s={},n=e(`<h1 id="http" tabindex="-1"><a class="header-anchor" href="#http" aria-hidden="true">#</a> HTTP</h1><h2 id="当我们输入网址后发生了什么" tabindex="-1"><a class="header-anchor" href="#当我们输入网址后发生了什么" aria-hidden="true">#</a> 当我们输入网址后发生了什么</h2><p>当你在浏览器中输入一个网址并按下回车键时，发生了以下一系列的步骤，通常包括：</p><ol><li><p><strong>DNS解析（Domain Name System）：</strong></p><ul><li>浏览器首先会检查输入的网址，如果它是一个域名（如www.example.com），则需要将域名解析为对应的 IP 地址。这个过程通过 DNS 解析完成，浏览器会向本地 DNS 服务器发送请求，获取对应域名的 IP 地址。</li></ul></li><li><p><strong>建立TCP连接：</strong></p><ul><li>一旦浏览器获得了目标服务器的 IP 地址，它就会尝试与服务器建立 TCP 连接。这是通过三次握手过程完成的，确保客户端和服务器都能够正常通信。</li></ul></li><li><p><strong>发起HTTP请求：</strong></p><ul><li>浏览器通过已建立的 TCP 连接向服务器发送一个 HTTP 请求。这个请求包含了你想要获取的资源的信息，比如网页的 HTML 内容、样式表、JavaScript 文件等。</li></ul></li><li><p><strong>服务器处理请求：</strong></p><ul><li>服务器接收到浏览器发送的 HTTP 请求后，会根据请求的内容进行处理。这可能涉及到从数据库中检索数据、运行服务器端的脚本等操作。</li></ul></li><li><p><strong>服务器返回HTTP响应：</strong></p><ul><li>服务器根据处理结果生成一个 HTTP 响应，其中包含了请求资源的信息。这个响应包括一个状态码（表示请求成功、重定向、错误等）、响应头（包含元信息，如内容类型、日期等）、以及响应体（实际的数据，如HTML文件的内容）。</li></ul></li><li><p><strong>浏览器接收响应：</strong></p><ul><li>浏览器接收到来自服务器的 HTTP 响应后，它会检查状态码。如果状态码表示成功（通常是2xx），浏览器会继续处理响应，否则可能会展示错误页面或者执行相应的错误处理。</li></ul></li><li><p><strong>渲染页面：</strong></p><ul><li>如果响应是一个 HTML 页面，浏览器会开始解析 HTML、构建 DOM（文档对象模型）和 CSSSheets，然后将它们组合起来形成一个渲染列表。接着，浏览器根据渲染树展示页面内容。</li></ul></li><li><p><strong>关闭连接：</strong></p><ul><li>一旦页面被完全加载，浏览器可能会关闭与服务器的连接，除非这个连接需要保持活动状态以获取其他资源（例如图片、样式表等）。</li></ul></li></ol><p>这是一个简化的描述，实际上涉及到许多优化和复杂的步骤，比如缓存、HTTP/2 多路复用等。整个过程称为浏览器的“网络请求生命周期”，而上述步骤构成了一次常规的网页加载过程。</p><h2 id="http协议详解" tabindex="-1"><a class="header-anchor" href="#http协议详解" aria-hidden="true">#</a> HTTP协议详解</h2><p>HTTP（Hypertext Transfer Protocol）是一种用于在网络上传输超文本数据的协议。它是一个无状态、应用层的协议，通常基于TCP协议，用于在客户端和服务器之间传输信息。以下是HTTP协议的一些关键特点和详解：</p><ol><li><p><strong>请求-响应模型：</strong></p><ul><li>HTTP是一个请求-响应协议。客户端发送HTTP请求到服务器，服务器收到请求后返回HTTP响应。请求和响应都由多行文本组成，包含有关请求或响应的信息。</li></ul></li><li><p><strong>无状态（Stateless）:</strong></p><ul><li>HTTP协议是无状态的，每个请求都是独立的，服务器不会记录之前的请求信息。这使得每个请求都是相互独立的，但也导致了一些在处理复杂事务时的挑战。</li></ul></li><li><p><strong>URI（Uniform Resource Identifier）:</strong></p><ul><li>URI是一种标识资源的方式。在HTTP中，URL（Uniform Resource Locator）是URI的一种具体形式，用于指定资源的位置。</li></ul></li><li><p><strong>方法（Methods）:</strong></p><ul><li>HTTP定义了一些请求方法，最常见的是： <ul><li><strong>GET：</strong> 从服务器获取资源。</li><li><strong>POST：</strong> 向服务器提交数据，用于创建新资源。</li><li><strong>PUT：</strong> 更新服务器上的资源。</li><li><strong>DELETE：</strong> 请求服务器删除指定的资源。</li><li><strong>HEAD：</strong> 与GET类似，但服务器只返回首部，不返回实体主体。</li></ul></li></ul></li><li><p><strong>状态码（Status Codes）:</strong></p><ul><li>HTTP响应包含一个状态码，表示服务器对请求的处理结果。常见的状态码包括： <ul><li><strong>200 OK：</strong> 请求成功。</li><li><strong>404 Not Found：</strong> 资源未找到。</li><li><strong>500 Internal Server Error：</strong> 服务器内部错误。</li></ul></li></ul></li><li><p><strong>报文结构：</strong></p><ul><li>HTTP报文分为请求报文和响应报文。每个报文都包含三个部分： <ul><li><strong>起始行（Start Line）：</strong> 包含方法（请求报文）或状态码（响应报文）。</li><li><strong>首部字段（Headers）：</strong> 包含一系列键值对，用于描述报文的属性。</li><li><strong>实体主体（Body）：</strong> 包含请求或响应的实际数据。</li></ul></li></ul></li><li><p><strong>连接管理：</strong></p><ul><li>HTTP/1.1引入了持久连接（Keep-Alive），允许在单个连接上发送多个请求和响应，减少了每次请求的连接建立和关闭的开销。</li></ul></li><li><p><strong>Cookie 和 Session：</strong></p><ul><li>HTTP通过Cookie和Session机制支持状态保持。服务器可以通过Set-Cookie头将Cookie发送给客户端，客户端将Cookie存储并在后续请求中发送回服务器。</li></ul></li><li><p><strong>安全性：</strong></p><ul><li>HTTPS是基于HTTP的安全协议，通过使用SSL/TLS加密通信，确保数据在传输过程中的机密性和完整性。</li></ul></li></ol><p>HTTP是互联网上最基本、最重要的协议之一，它为客户端和服务器之间的通信提供了标准化的方式。随着Web的发展，HTTP的版本也在不断更新，新的特性和优化被引入以适应不断变化的网络环境。</p><h2 id="cookie和session的区别" tabindex="-1"><a class="header-anchor" href="#cookie和session的区别" aria-hidden="true">#</a> Cookie和Session的区别</h2><p>Cookie 和 Session 都是用于在客户端和服务器之间保持状态的机制，但它们有一些关键的区别：</p><ol><li><p><strong>存储位置：</strong></p><ul><li><strong>Cookie：</strong> 存储在客户端（浏览器）中。Cookie 是服务器发送给客户端并存储在客户端的小型文本文件，通常包含有关用户的信息。</li><li><strong>Session：</strong> 存储在服务器端。Session 数据通常存储在服务器的内存中或数据库中，每个用户都有一个唯一的会话标识符，用于检索相关的会话数据。</li></ul></li><li><p><strong>安全性：</strong></p><ul><li><strong>Cookie：</strong> 相对不安全。Cookie 存储在客户端，因此可以被用户查看和编辑。为了增加安全性，可以使用安全标志和HttpOnly标志。</li><li><strong>Session：</strong> 相对安全。因为 Session 数据存储在服务器上，用户无法直接访问或修改会话数据。</li></ul></li><li><p><strong>容量：</strong></p><ul><li><strong>Cookie：</strong> 存储的数据有限，通常在4KB左右。过多的 Cookie 可能会影响请求性能。</li><li><strong>Session：</strong> 存储的数据相对较大，受服务器内存和配置的限制。</li></ul></li><li><p><strong>过期时间：</strong></p><ul><li><strong>Cookie：</strong> 可以设置过期时间，可以是会话级别（浏览器关闭时过期）或具有固定的过期日期。</li><li><strong>Session：</strong> 通常在用户关闭浏览器或一定时间内不活动时过期，但具体过期规则由服务器管理。</li></ul></li><li><p><strong>跨域：</strong></p><ul><li><strong>Cookie：</strong> 遵循同源策略，有限制跨域访问。</li><li><strong>Session：</strong> 通常由服务器生成并存储在服务器上，与域无关，可以在多个域之间共享。</li></ul></li><li><p><strong>使用场景：</strong></p><ul><li><strong>Cookie：</strong> 适合存储小型且不敏感的数据，如用户偏好设置、跟踪用户行为等。</li><li><strong>Session：</strong> 适合存储敏感信息，如用户登录状态、购物车内容等。</li></ul></li><li><p><strong>传输方式：</strong></p><ul><li><strong>Cookie：</strong> 会随着 HTTP 请求一起发送到服务器。每次请求都会带上相应的 Cookie。</li><li><strong>Session：</strong> 通常通过 Cookie 中的会话标识符来关联用户与服务器端存储的会话数据。</li></ul></li></ol><p>综合考虑，Cookie和Session通常一起使用。用户登录后，服务器生成一个唯一的会话标识符，将其存储在一个 Cookie 中，同时在服务器端创建一个与该标识符相关联的 Session。这样，通过 Cookie 中的标识符，服务器可以识别用户，并从 Session 中检索相关的数据。这种结合使用的方式兼顾了安全性和性能。</p><h3 id="为什么会有这样的区别" tabindex="-1"><a class="header-anchor" href="#为什么会有这样的区别" aria-hidden="true">#</a> 为什么会有这样的区别</h3><p>Cookie 和 Session 之间的区别主要是由于它们的设计目标和实现机制不同，以及在 web 应用程序中的不同用途。以下是导致它们区别的一些原因：</p><ol><li><p><strong>存储位置：</strong></p><ul><li><strong>Cookie：</strong> 设计用于在客户端存储小型的用户数据。它是通过在浏览器中存储一个小型的文本文件来实现的，使得客户端可以在用户的本地设备上持久保存一些信息。</li><li><strong>Session：</strong> 由于它的数据存储在服务器上，因此可以更安全地存储敏感信息，并且无法被客户端直接访问。</li></ul></li><li><p><strong>安全性：</strong></p><ul><li><strong>Cookie：</strong> 存储在客户端，因此对于用户来说相对不安全。虽然可以通过一些手段（如设置安全标志和 HttpOnly 标志）增加安全性，但用户仍然可以查看和编辑 Cookie。</li><li><strong>Session：</strong> 存储在服务器上，用户无法直接访问或修改 Session 数据，因此相对更安全。</li></ul></li><li><p><strong>容量：</strong></p><ul><li><strong>Cookie：</strong> 容量相对较小，通常在4KB左右。这是因为每个 HTTP 请求都会携带 Cookie 数据，而过大的 Cookie 数据可能会影响请求性能。</li><li><strong>Session：</strong> 存储在服务器上，可以存储相对较大的数据，受服务器内存和配置的限制。</li></ul></li><li><p><strong>过期时间：</strong></p><ul><li><strong>Cookie：</strong> 可以设置过期时间，可以是会话级别（浏览器关闭时过期）或具有固定的过期日期。</li><li><strong>Session：</strong> 通常在用户关闭浏览器或一定时间内不活动时过期，具体过期规则由服务器管理。</li></ul></li><li><p><strong>跨域：</strong></p><ul><li><strong>Cookie：</strong> 遵循同源策略，有限制跨域访问。Cookie 是与域名关联的。</li><li><strong>Session：</strong> 通常由服务器生成并存储在服务器上，与域无关，可以在多个域之间共享。</li></ul></li><li><p><strong>使用场景：</strong></p><ul><li><strong>Cookie：</strong> 适合存储小型且不敏感的数据，如用户偏好设置、跟踪用户行为等。</li><li><strong>Session：</strong> 适合存储敏感信息，如用户登录状态、购物车内容等。</li></ul></li></ol><p>这些差异主要反映了设计决策和权衡。Cookie 和 Session 在实现用户身份验证、状态保持和数据传递等方面都有各自的优势，开发者根据具体需求选择使用其中的一种或结合使用。</p><h2 id="http缓存机制" tabindex="-1"><a class="header-anchor" href="#http缓存机制" aria-hidden="true">#</a> HTTP缓存机制</h2><p>HTTP缓存机制是一种通过在客户端和服务器之间存储已请求资源的副本来提高性能、减少网络带宽使用的技术。缓存机制允许浏览器在再次请求相同资源时，直接使用本地缓存而不是向服务器重新请求。这可以降低网络延迟和减轻服务器负载。</p><p>HTTP缓存机制主要涉及两个方面：客户端缓存和服务器缓存。</p><h3 id="客户端缓存" tabindex="-1"><a class="header-anchor" href="#客户端缓存" aria-hidden="true">#</a> 客户端缓存：</h3><ol><li><p><strong>Expires 头：</strong></p><ul><li>服务器在响应中发送 <code>Expires</code> 头，指定资源的过期时间。浏览器在此过期时间之前可以直接使用本地缓存。</li></ul><div class="language-http line-numbers-mode" data-ext="http"><pre class="language-http"><code><span class="token header"><span class="token header-name keyword">Expires</span><span class="token punctuation">:</span> <span class="token header-value">Wed, 21 Oct 2023 07:28:00 GMT</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p><strong>Cache-Control 头：</strong></p><ul><li><code>Cache-Control</code> 头提供了更为灵活的缓存控制选项，可以指定缓存的最大时长、是否允许缓存代理等。</li></ul><div class="language-http line-numbers-mode" data-ext="http"><pre class="language-http"><code><span class="token header"><span class="token header-name keyword">Cache-Control</span><span class="token punctuation">:</span> <span class="token header-value">max-age=3600, must-revalidate</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><code>max-age</code> 指定了资源被认为是新鲜的最大时间（秒），<code>must-revalidate</code> 指示客户端必须在使用过期资源之前重新验证。</li></ul></li><li><p><strong>Last-Modified 和 If-Modified-Since 头：</strong></p><ul><li>服务器通过 <code>Last-Modified</code> 头指示资源的最后修改时间。客户端在后续请求中可以通过 <code>If-Modified-Since</code> 头将上次获取资源的时间发送给服务器，如果资源在此时间后没有发生变化，服务器返回 304 Not Modified，客户端使用本地缓存。</li></ul><div class="language-http line-numbers-mode" data-ext="http"><pre class="language-http"><code><span class="token header"><span class="token header-name keyword">Last-Modified</span><span class="token punctuation">:</span> <span class="token header-value">Wed, 21 Oct 2023 07:28:00 GMT</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p><strong>ETag 和 If-None-Match 头：</strong></p><ul><li><code>ETag</code> 是服务器生成的资源唯一标识符。客户端在后续请求中可以通过 <code>If-None-Match</code> 头将上次获取资源时收到的 <code>ETag</code> 发送给服务器，如果资源的 <code>ETag</code> 没有发生变化，服务器返回 304 Not Modified，客户端使用本地缓存。</li></ul><div class="language-http line-numbers-mode" data-ext="http"><pre class="language-http"><code><span class="token header"><span class="token header-name keyword">ETag</span><span class="token punctuation">:</span> <span class="token header-value">&quot;abc123&quot;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ol><h3 id="服务器缓存" tabindex="-1"><a class="header-anchor" href="#服务器缓存" aria-hidden="true">#</a> 服务器缓存：</h3><ol><li><p><strong>Cache-Control 头：</strong></p><ul><li>服务器通过 <code>Cache-Control</code> 头来指定在客户端和代理服务器中的缓存行为。</li></ul><div class="language-http line-numbers-mode" data-ext="http"><pre class="language-http"><code><span class="token header"><span class="token header-name keyword">Cache-Control</span><span class="token punctuation">:</span> <span class="token header-value">public, max-age=3600</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><code>public</code> 表示响应可以被任何缓存存储，包括客户端和代理服务器。</li></ul></li><li><p><strong>Pragma 头：</strong></p><ul><li><code>Pragma: no-cache</code> 是一个过时的头部，它通常用于禁用客户端缓存。</li></ul></li><li><p><strong>Vary 头：</strong></p><ul><li><code>Vary</code> 头决定了缓存的变体，即哪些请求头的改变会影响缓存的有效性。</li></ul><div class="language-http line-numbers-mode" data-ext="http"><pre class="language-http"><code><span class="token header"><span class="token header-name keyword">Vary</span><span class="token punctuation">:</span> <span class="token header-value">Accept-Encoding, User-Agent</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>上述例子表示缓存的有效性受到请求头中的 <code>Accept-Encoding</code> 和 <code>User-Agent</code> 的影响。</li></ul></li><li><p><strong>Pragma 头：</strong></p><ul><li><code>Pragma: no-cache</code> 是一个过时的头部，它通常用于禁用客户端缓存。</li></ul></li></ol><p>HTTP缓存机制的合理使用可以显著提升Web应用的性能，减轻服务器负载，降低网络带宽的使用。不同的场景可能需要使用不同的缓存策略，开发者需要根据具体情况选择合适的缓存配置。</p><h2 id="了解tcp-ip协议栈" tabindex="-1"><a class="header-anchor" href="#了解tcp-ip协议栈" aria-hidden="true">#</a> 了解TCP/IP协议栈</h2><h3 id="iso-osi七层网络模型" tabindex="-1"><a class="header-anchor" href="#iso-osi七层网络模型" aria-hidden="true">#</a> ISO/OSI七层网络模型</h3><p>tcp慢：确认重传机制</p>`,28),t=[n];function a(r,d){return o(),l("div",null,t)}const c=i(s,[["render",a],["__file","index.html.vue"]]);export{c as default};
